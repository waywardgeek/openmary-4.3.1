<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_29) on Wed Nov 30 14:31:32 CET 2011 -->
<TITLE>
FFT (Mary Java API)
</TITLE>

<META NAME="date" CONTENT="2011-11-30">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="FFT (Mary Java API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/FFT.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../marytts/util/math/DTW.RecurssiveDTW.html" title="class in marytts.util.math"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../marytts/util/math/FFTMixedRadix.html" title="class in marytts.util.math"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?marytts/util/math/FFT.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FFT.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
marytts.util.math</FONT>
<BR>
Class FFT</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>marytts.util.math.FFT</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>FFT</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Marc Schr&ouml;der</DD>
</DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#FFT()">FFT</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#autoCorrelate(double[])">autoCorrelate</A></B>(double[]&nbsp;signal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the autocorrelation of a signal, by inverse transformation of its
 power spectrum.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#autoCorrelateWithZeroPadding(double[])">autoCorrelateWithZeroPadding</A></B>(double[]&nbsp;signal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the autocorrelation of a signal, by inverse transformation of its
 power spectrum.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#computeAmplitudeSpectrum_FD(double[])">computeAmplitudeSpectrum_FD</A></B>(double[]&nbsp;fft)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From the result of the FFT (in the frequency domain), compute the absolute value
 for each positive frequency, i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#computeAmplitudeSpectrum(double[])">computeAmplitudeSpectrum</A></B>(double[]&nbsp;signal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method for computing the absolute amplitude spectrum of a real signal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#computeLogAmplitudeSpectrum_FD(double[])">computeLogAmplitudeSpectrum_FD</A></B>(double[]&nbsp;fft)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From the result of the FFT (in the frequency domain), compute the log amplitude
 for each positive frequency.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#computeLogAmplitudeSpectrum(double[])">computeLogAmplitudeSpectrum</A></B>(double[]&nbsp;signal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method for computing the log amplitude spectrum of a real signal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#computeLogPowerSpectrum_FD(double[])">computeLogPowerSpectrum_FD</A></B>(double[]&nbsp;fft)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From the result of the FFT, compute the log (dB) power
 for each positive frequency.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#computeLogPowerSpectrum(double[])">computeLogPowerSpectrum</A></B>(double[]&nbsp;signal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method for computing the log (dB) power spectrum of a real signal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#computePhaseSpectrum_FD(double[])">computePhaseSpectrum_FD</A></B>(double[]&nbsp;fft)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From the result of the FFT (in the frequency domain), compute the phase spectrum
 for each positive frequency.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#computePowerSpectrum_FD(double[])">computePowerSpectrum_FD</A></B>(double[]&nbsp;fft)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From the result of the FFT (in the frequency domain), compute the power
 for each positive frequency.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#computePowerSpectrum(double[])">computePowerSpectrum</A></B>(double[]&nbsp;signal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method for computing the absolute power spectrum of a real signal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#convolve_FD(double[], double[])">convolve_FD</A></B>(double[]&nbsp;signal1,
            double[]&nbsp;fft2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the convolution of two signals, by multiplying them in the frequency domain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#convolve_FD(double[], double[], double)">convolve_FD</A></B>(double[]&nbsp;signal1,
            double[]&nbsp;fft2,
            double&nbsp;deltaT)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the convolution of two signals, by multiplying them in the frequency domain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#convolve(double[], double[])">convolve</A></B>(double[]&nbsp;signal1,
         double[]&nbsp;signal2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the convolution of two signals, by multiplying them in the frequency domain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#convolve(double[], double[], double)">convolve</A></B>(double[]&nbsp;signal1,
         double[]&nbsp;signal2,
         double&nbsp;deltaT)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the convolution of two signals, by multiplying them in the frequency domain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#convolveWithZeroPadding(double[], double[])">convolveWithZeroPadding</A></B>(double[]&nbsp;signal1,
                        double[]&nbsp;signal2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the convolution of two signals, by multipying them in the frequency domain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#convolveWithZeroPadding(double[], double[], double)">convolveWithZeroPadding</A></B>(double[]&nbsp;signal1,
                        double[]&nbsp;signal2,
                        double&nbsp;deltaT)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the convolution of two signals, by multipying them in the frequency domain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#correlate(double[], double[])">correlate</A></B>(double[]&nbsp;signal1,
          double[]&nbsp;signal2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the correlation of two signals, by multiplying the transform of signal2
 with the conjugate complex of the transform of signal1, in the frequency domain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#correlateWithZeroPadding(double[], double[])">correlateWithZeroPadding</A></B>(double[]&nbsp;signal1,
                         double[]&nbsp;signal2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the correlation of two signals, by multipying them in the frequency domain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#main(java.lang.String[])">main</A></B>(java.lang.String[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#realTransform(double[], boolean)">realTransform</A></B>(double[]&nbsp;data,
              boolean&nbsp;inverse)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates the Fourier transform of a set of n real-valued data points.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#transform(double[], boolean)">transform</A></B>(double[]&nbsp;realAndImag,
          boolean&nbsp;inverse)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Carry out the FFT or inverse FFT, and return the result in the same arrays given
 as parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../marytts/util/math/FFT.html#transform(double[], double[], boolean)">transform</A></B>(double[]&nbsp;real,
          double[]&nbsp;imag,
          boolean&nbsp;inverse)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Carry out the FFT or inverse FFT, and return the result in the same arrays given
 as parameters.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FFT()"><!-- --></A><H3>
FFT</H3>
<PRE>
public <B>FFT</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="computeLogPowerSpectrum(double[])"><!-- --></A><H3>
computeLogPowerSpectrum</H3>
<PRE>
public static double[] <B>computeLogPowerSpectrum</B>(double[]&nbsp;signal)</PRE>
<DL>
<DD>Convenience method for computing the log (dB) power spectrum of a real signal.
 The signal can be of any length; internally, zeroes will be added if signal length 
 is not a power of two.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal</CODE> - the real signal for which to compute the power spectrum.
<DT><B>Returns:</B><DD>the power spectrum, as an array of length N/2 (where N is the power of two
 greater than or equal to signal.length):
 the log of the squared absolute values of the lower half of the complex
 fourier transform array.</DL>
</DD>
</DL>
<HR>

<A NAME="computeLogPowerSpectrum_FD(double[])"><!-- --></A><H3>
computeLogPowerSpectrum_FD</H3>
<PRE>
public static double[] <B>computeLogPowerSpectrum_FD</B>(double[]&nbsp;fft)</PRE>
<DL>
<DD>From the result of the FFT, compute the log (dB) power
 for each positive frequency.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fft</CODE> - the array of real and imag parts of the complex number array,
 fft[0] = real[0], fft[1] = real[N/2], fft[2*i] = real[i], fft[2*i+1] = imag[i] for 1<=i<N/2
<DT><B>Returns:</B><DD>an array of length real.length/2 containing numbers 
 representing the log of the square of the absolute value of each complex number,
 p[i] = real[i]*real[i] + imag[i]*imag[i]</DL>
</DD>
</DL>
<HR>

<A NAME="computePowerSpectrum(double[])"><!-- --></A><H3>
computePowerSpectrum</H3>
<PRE>
public static double[] <B>computePowerSpectrum</B>(double[]&nbsp;signal)</PRE>
<DL>
<DD>Convenience method for computing the absolute power spectrum of a real signal.
 The signal can be of any length; internally, zeroes will be added if signal length 
 is not a power of two.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal</CODE> - the real signal for which to compute the power spectrum.
<DT><B>Returns:</B><DD>the power spectrum, as an array of length N/2 (where N is the power of two
 greater than or equal to signal.length):
 the squared absolute values of the lower half of the complex
 fourier transform array.</DL>
</DD>
</DL>
<HR>

<A NAME="computePowerSpectrum_FD(double[])"><!-- --></A><H3>
computePowerSpectrum_FD</H3>
<PRE>
public static double[] <B>computePowerSpectrum_FD</B>(double[]&nbsp;fft)</PRE>
<DL>
<DD>From the result of the FFT (in the frequency domain), compute the power
 for each positive frequency.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fft</CODE> - the array of real and imag parts of the complex number array,
 fft[0] = real[0], fft[1] = real[N/2], fft[2*i] = real[i], fft[2*i+1] = imag[i] for 1<=i<N/2
<DT><B>Returns:</B><DD>an array of length real.length/2 containing numbers 
 representing the square of the absolute value of each complex number,
 p[i] = real[i]*real[i] + imag[i]*imag[i]</DL>
</DD>
</DL>
<HR>

<A NAME="computeLogAmplitudeSpectrum(double[])"><!-- --></A><H3>
computeLogAmplitudeSpectrum</H3>
<PRE>
public static double[] <B>computeLogAmplitudeSpectrum</B>(double[]&nbsp;signal)</PRE>
<DL>
<DD>Convenience method for computing the log amplitude spectrum of a real signal.
 The signal can be of any length; internally, zeroes will be added if signal length 
 is not a power of two.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal</CODE> - the real signal for which to compute the power spectrum.
<DT><B>Returns:</B><DD>the log amplitude spectrum, as an array of length N/2 (where N is the power of two
 greater than or equal to signal.length):
 the log of the absolute values of the lower half of the complex
 fourier transform array.</DL>
</DD>
</DL>
<HR>

<A NAME="computeLogAmplitudeSpectrum_FD(double[])"><!-- --></A><H3>
computeLogAmplitudeSpectrum_FD</H3>
<PRE>
public static double[] <B>computeLogAmplitudeSpectrum_FD</B>(double[]&nbsp;fft)</PRE>
<DL>
<DD>From the result of the FFT (in the frequency domain), compute the log amplitude
 for each positive frequency.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fft</CODE> - the array of real and imag parts of the complex number array,
 fft[0] = real[0], fft[1] = real[N/2], fft[2*i] = real[i], fft[2*i+1] = imag[i] for 1<=i<N/2
<DT><B>Returns:</B><DD>an array of length real.length/2 containing numbers 
 representing the log of the square of the absolute value of each complex number,
 p[i] = real[i]*real[i] + imag[i]*imag[i]</DL>
</DD>
</DL>
<HR>

<A NAME="computeAmplitudeSpectrum(double[])"><!-- --></A><H3>
computeAmplitudeSpectrum</H3>
<PRE>
public static double[] <B>computeAmplitudeSpectrum</B>(double[]&nbsp;signal)</PRE>
<DL>
<DD>Convenience method for computing the absolute amplitude spectrum of a real signal.
 The signal can be of any length; internally, zeroes will be added if signal length 
 is not a power of two.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal</CODE> - the real signal for which to compute the power spectrum.
<DT><B>Returns:</B><DD>the power spectrum, as an array of length N/2 (where N is the power of two
 greater than or equal to signal.length):
 the absolute values of the lower half of the complex
 fourier transform array.</DL>
</DD>
</DL>
<HR>

<A NAME="computeAmplitudeSpectrum_FD(double[])"><!-- --></A><H3>
computeAmplitudeSpectrum_FD</H3>
<PRE>
public static double[] <B>computeAmplitudeSpectrum_FD</B>(double[]&nbsp;fft)</PRE>
<DL>
<DD>From the result of the FFT (in the frequency domain), compute the absolute value
 for each positive frequency, i.e. the norm of each complex number
  in the lower half of the array
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fft</CODE> - the array of real and imag parts of the complex number array,
 fft[0] = real[0], fft[1] = real[N/2], fft[2*i] = real[i], fft[2*i+1] = imag[i] for 1<=i<N/2
<DT><B>Returns:</B><DD>an array of length real.length/2 containing numbers 
 representing the absolute value of each complex number,
 r[i] = sqrt(real[i]*real[i] + imag[i]*imag[i])</DL>
</DD>
</DL>
<HR>

<A NAME="computePhaseSpectrum_FD(double[])"><!-- --></A><H3>
computePhaseSpectrum_FD</H3>
<PRE>
public static double[] <B>computePhaseSpectrum_FD</B>(double[]&nbsp;fft)</PRE>
<DL>
<DD>From the result of the FFT (in the frequency domain), compute the phase spectrum
 for each positive frequency.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fft</CODE> - the array of real and imag parts of the complex number array,
 fft[0] = real[0], fft[1] = real[N/2], fft[2*i] = real[i], fft[2*i+1] = imag[i] for 1<=i<N/2
<DT><B>Returns:</B><DD>an array of length real.length/2 containing numbers 
 representing the phases of each complex number,
 phase[i] = atan(imag[i], real[i])</DL>
</DD>
</DL>
<HR>

<A NAME="transform(double[], double[], boolean)"><!-- --></A><H3>
transform</H3>
<PRE>
public static void <B>transform</B>(double[]&nbsp;real,
                             double[]&nbsp;imag,
                             boolean&nbsp;inverse)</PRE>
<DL>
<DD>Carry out the FFT or inverse FFT, and return the result in the same arrays given
 as parameters. In the case of the "forward" FFT, real is the signal to
 transform, and imag is an empty array. After the call, real will hold
 the real part of the complex frequency array, and imag will hold the imaginary part.
 They are ordered such that first come positive frequencies from 0 to fmax, then
 the negative frequencies from -fmax to 0 (which are the mirror image of the positive
 frequencies).
 In the case of the inverse FFT, real and imag are in input the real and imaginary part of the 
 complex frequencies, and in output, real is the signal. The method already computes the
 division by array length required for the inverse transform.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>real</CODE> - in "forward" FFT: as input=the time-domain signal to transform, as output=the real part of the
 complex frequencies; in inverse FFT: as input=the real part of the complex frequencies, as output=
 the time-domain signal.<DD><CODE>imag</CODE> - in "forward" FFT: as input=an empty array, as output=the imaginary part of the
 complex frequencies; in inverse FFT: as input=the imaginary part of the complex frequencies, as output=
 not used.<DD><CODE>inverse</CODE> - whether to calculate the FFT or the inverse FFT.</DL>
</DD>
</DL>
<HR>

<A NAME="transform(double[], boolean)"><!-- --></A><H3>
transform</H3>
<PRE>
public static void <B>transform</B>(double[]&nbsp;realAndImag,
                             boolean&nbsp;inverse)</PRE>
<DL>
<DD>Carry out the FFT or inverse FFT, and return the result in the same arrays given
 as parameters. This works exactly like #transform(real, imag, boolean),
 but data is represented differently: the even indices of the input array
 hold the real part, the odd indices the imag part of each complex number.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>realAndImag</CODE> - the array of complex numbers to transform<DD><CODE>inverse</CODE> - whether to calculate the FFT or the inverse FFT.</DL>
</DD>
</DL>
<HR>

<A NAME="realTransform(double[], boolean)"><!-- --></A><H3>
realTransform</H3>
<PRE>
public static void <B>realTransform</B>(double[]&nbsp;data,
                                 boolean&nbsp;inverse)</PRE>
<DL>
<DD>Calculates the Fourier transform of a set of n real-valued data points. Replaces this data (which
    is stored in array data[1..n]) by the positive frequency half of its complex Fourier transform.
    The real-valued first and last components of the complex transform are returned as elements
    data[1] and data[2], respectively. n must be a power of 2. This routine also calculates the
    inverse transform of a complex data array if it is the transform of real data. (Result in this case
    must be multiplied by 2/n.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="convolveWithZeroPadding(double[], double[], double)"><!-- --></A><H3>
convolveWithZeroPadding</H3>
<PRE>
public static double[] <B>convolveWithZeroPadding</B>(double[]&nbsp;signal1,
                                               double[]&nbsp;signal2,
                                               double&nbsp;deltaT)</PRE>
<DL>
<DD>Compute the convolution of two signals, by multipying them in the frequency domain.
 Normalise the result with respect to deltaT (the inverse of the sampling rate).
 This method applies zero padding where necessary to ensure that the result
 is not polluted because of assumed periodicity. The two signals need not be of equal length.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal1</CODE> - <DD><CODE>signal2</CODE> - <DD><CODE>deltaT,</CODE> - the time difference between two samples (= 1/samplingrate)
<DT><B>Returns:</B><DD>the convolved signal, with length signal1.length+signal2.length</DL>
</DD>
</DL>
<HR>

<A NAME="convolveWithZeroPadding(double[], double[])"><!-- --></A><H3>
convolveWithZeroPadding</H3>
<PRE>
public static double[] <B>convolveWithZeroPadding</B>(double[]&nbsp;signal1,
                                               double[]&nbsp;signal2)</PRE>
<DL>
<DD>Compute the convolution of two signals, by multipying them in the frequency domain.
 This method applies zero padding where necessary to ensure that the result
 is not polluted because of assumed periodicity. The two signals need not be of equal length.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal1</CODE> - <DD><CODE>signal2</CODE> - 
<DT><B>Returns:</B><DD>the convolved signal, with length signal1.length+signal2.length</DL>
</DD>
</DL>
<HR>

<A NAME="convolve(double[], double[], double)"><!-- --></A><H3>
convolve</H3>
<PRE>
public static double[] <B>convolve</B>(double[]&nbsp;signal1,
                                double[]&nbsp;signal2,
                                double&nbsp;deltaT)</PRE>
<DL>
<DD>Compute the convolution of two signals, by multiplying them in the frequency domain.
 Normalise the result with respect to deltaT (the inverse of the sampling rate).
 This is the core method, requiring two signals of equal length, which must be
 a power of two, and not checking
 for pollution arising from the assumed periodicity of both signals.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal1</CODE> - <DD><CODE>signal2</CODE> - <DD><CODE>deltaT,</CODE> - the time difference between two samples (= 1/samplingrate)
<DT><B>Returns:</B><DD>the convolved signal, of the same length as the two input signals
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the two input signals do not have the same length.</DL>
</DD>
</DL>
<HR>

<A NAME="convolve(double[], double[])"><!-- --></A><H3>
convolve</H3>
<PRE>
public static double[] <B>convolve</B>(double[]&nbsp;signal1,
                                double[]&nbsp;signal2)</PRE>
<DL>
<DD>Compute the convolution of two signals, by multiplying them in the frequency domain.
 This is the core method, requiring two signals of equal length, which must be
 a power of two, and not checking
 for pollution arising from the assumed periodicity of both signals.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal1</CODE> - <DD><CODE>signal2</CODE> - 
<DT><B>Returns:</B><DD>the convolved signal, of the same length as the two input signals
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the two input signals do not have the same length.</DL>
</DD>
</DL>
<HR>

<A NAME="convolve_FD(double[], double[], double)"><!-- --></A><H3>
convolve_FD</H3>
<PRE>
public static double[] <B>convolve_FD</B>(double[]&nbsp;signal1,
                                   double[]&nbsp;fft2,
                                   double&nbsp;deltaT)</PRE>
<DL>
<DD>Compute the convolution of two signals, by multiplying them in the frequency domain.
 Normalise the result with respect to deltaT (the inverse of the sampling rate).
 This is a specialised version of the core method, requiring two signals of equal length,
 which must be a power of two, and not checking
 for pollution arising from the assumed periodicity of both signals.
 In this version, the first signal is provided in the time domain, while the second is
 already transformed into the frequency domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal1</CODE> - the first input signal, in the time domain<DD><CODE>fft2</CODE> - the complex transform of the second signal, in the frequency domain
 fft[0] = real[0], fft[1] = real[N/2], fft[2*i] = real[i], fft[2*i+1] = imag[i] for 1<=i<N/2<DD><CODE>deltaT,</CODE> - the time difference between two samples (= 1/samplingrate)
<DT><B>Returns:</B><DD>the convolved signal, of the same length as the two input signals
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the two input signals do not have the same length.</DL>
</DD>
</DL>
<HR>

<A NAME="convolve_FD(double[], double[])"><!-- --></A><H3>
convolve_FD</H3>
<PRE>
public static double[] <B>convolve_FD</B>(double[]&nbsp;signal1,
                                   double[]&nbsp;fft2)</PRE>
<DL>
<DD>Compute the convolution of two signals, by multiplying them in the frequency domain.
 This is a specialised version of the core method, requiring two signals of equal length,
 which must be a power of two, and not checking
 for pollution arising from the assumed periodicity of both signals.
 In this version, the first signal is provided in the time domain, while the second is
 already transformed into the frequency domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal1</CODE> - the first input signal, in the time domain<DD><CODE>fft2</CODE> - the complex transform of the second signal, in the frequency domain
 fft[0] = real[0], fft[1] = real[N/2], fft[2*i] = real[i], fft[2*i+1] = imag[i] for 1<=i<N/2
<DT><B>Returns:</B><DD>the convolved signal, of the same length as the two input signals
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the two input signals do not have the same length.</DL>
</DD>
</DL>
<HR>

<A NAME="correlateWithZeroPadding(double[], double[])"><!-- --></A><H3>
correlateWithZeroPadding</H3>
<PRE>
public static double[] <B>correlateWithZeroPadding</B>(double[]&nbsp;signal1,
                                                double[]&nbsp;signal2)</PRE>
<DL>
<DD>Compute the correlation of two signals, by multipying them in the frequency domain.
 This method applies zero padding where necessary to ensure that the result
 is not polluted because of assumed periodicity. The two signals need not be of equal length.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal1</CODE> - <DD><CODE>signal2</CODE> - 
<DT><B>Returns:</B><DD>the correlation function, with length signal1.length+signal2.length</DL>
</DD>
</DL>
<HR>

<A NAME="correlate(double[], double[])"><!-- --></A><H3>
correlate</H3>
<PRE>
public static double[] <B>correlate</B>(double[]&nbsp;signal1,
                                 double[]&nbsp;signal2)</PRE>
<DL>
<DD>Compute the correlation of two signals, by multiplying the transform of signal2
 with the conjugate complex of the transform of signal1, in the frequency domain.
 Sign convention: If signal2 is shifted by n to the right of signal2, then the correlation
 function will have a peak at positive n.
 This is the core method, requiring two signals of equal length, which must be
 a power of two, and not checking
 for pollution arising from the assumed periodicity of both signals.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal1</CODE> - <DD><CODE>signal2</CODE> - 
<DT><B>Returns:</B><DD>the correlated signal, of the same length as the two input signals
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the two input signals do not have the same length.</DL>
</DD>
</DL>
<HR>

<A NAME="autoCorrelate(double[])"><!-- --></A><H3>
autoCorrelate</H3>
<PRE>
public static double[] <B>autoCorrelate</B>(double[]&nbsp;signal)</PRE>
<DL>
<DD>Compute the autocorrelation of a signal, by inverse transformation of its
 power spectrum.
 This is the core method, requiring a signal whose length must be
 a power of two, and not checking
 for pollution arising from the assumed periodicity of the signal.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal</CODE> - 
<DT><B>Returns:</B><DD>the correlated signal, of the same length as the input signal</DL>
</DD>
</DL>
<HR>

<A NAME="autoCorrelateWithZeroPadding(double[])"><!-- --></A><H3>
autoCorrelateWithZeroPadding</H3>
<PRE>
public static double[] <B>autoCorrelateWithZeroPadding</B>(double[]&nbsp;signal)</PRE>
<DL>
<DD>Compute the autocorrelation of a signal, by inverse transformation of its
 power spectrum.
 This method applies zero padding where necessary to ensure that the result
 is not polluted because of assumed periodicity.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signal</CODE> - 
<DT><B>Returns:</B><DD>the correlated signal, of the same length as the input signal</DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(java.lang.String[]&nbsp;args)
                 throws java.lang.Exception</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/FFT.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../marytts/util/math/DTW.RecurssiveDTW.html" title="class in marytts.util.math"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../marytts/util/math/FFTMixedRadix.html" title="class in marytts.util.math"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?marytts/util/math/FFT.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FFT.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
